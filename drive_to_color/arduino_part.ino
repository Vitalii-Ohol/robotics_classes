#include <Wire.h>#include <MechaQMC5883.h>#include <stdint.h>#define irPin A0#define model 1080#define servoPin A1#define readLightR A3#define readLightL A2#define trigPin A4#define echoPin A5#define lPin 10#define rPin 11#define lDir1 7#define lDir2 8#define rDir1 12#define rDir2 13#define stepcount 20 //empty spaces#define wheeldiameter 65 //mm#define desireDistance 100 //cm#define speedMax 255#define speedMin 150#define range 1#define M_PI 3.14159265358979323846#define kp 5#define forw() ({ \  digitalWrite(lDir1, LOW); \  digitalWrite(lDir2, HIGH); \  digitalWrite(rDir1, LOW); \  digitalWrite(rDir2, HIGH); \})#define back() ({ \  digitalWrite(lDir1, HIGH); \  digitalWrite(lDir2, LOW); \  digitalWrite(rDir1, HIGH); \  digitalWrite(rDir2, LOW); \})#define left() ({ \  digitalWrite(lDir1, HIGH); \  digitalWrite(lDir2, LOW); \  digitalWrite(rDir1, LOW); \  digitalWrite(rDir2, HIGH); \})#define right() ({ \  digitalWrite(lDir1, LOW); \  digitalWrite(lDir2, HIGH); \  digitalWrite(rDir1, HIGH); \  digitalWrite(rDir2, LOW); \})MechaQMC5883 qmc;float circumference;float cm_step;int8_t actualL = -1;uint16_t counterL = 0;int8_t actualR = -1;uint16_t counterR = 0;int part1;int part2;int part3;int spd;int ll;int rr;int tmp;String read_string;uint8_t CMtoSteps(float cm) {	uint8_t result;	float f_result = cm / cm_step;	result = (uint8_t) f_result;	return result;}void move(uint16_t steps, uint8_t mspeed) {	counterL = 0;	counterR = 0;	while (steps > (counterL) && steps > (counterR)) {		ll = digitalRead(readLightL);		if (actualL != ll && actualL == HIGH) {			++counterL;		}		actualL = ll;		rr = digitalRead(readLightR);		if (actualR != rr && actualR == HIGH) {			++counterR;		}		actualR = rr;		if (steps > counterR) {			analogWrite(rPin, mspeed);		} else {			analogWrite(rPin, 0);		}		if (steps > counterL) {			analogWrite(lPin, mspeed);		} else {			analogWrite(lPin, 0);		}	}	analogWrite(lPin, 0);	analogWrite(rPin, 0);	counterL = 0;	counterR = 0;}void move2(uint16_t steps, uint8_t masterPower) {	float gx,gy,gz;	float gazimuth;	qmc.read(&gx,&gy,&gz, &gazimuth);	float gazimuth2 = qmc.azimuth(&gy,&gx);	float gangleXY;	gangleXY = atan2(gy,gx) * 180.0/M_PI; 	float gangleZ;	gangleZ = asin(gz/64.0) * 180.0/M_PI;	counterL = 0;	counterR = 0;	uint8_t slavePower = masterPower - 5;	int8_t error = 0;	while (steps > counterL) {		float x,y,z;		float azimuth;		qmc.read(&x,&y,&z, &azimuth);		float azimuth2 = qmc.azimuth(&y,&x);		float angleXY;		angleXY = atan2(y,x) * 180.0/M_PI; 		float angleZ;		angleZ = asin(z/64.0) * 180.0/M_PI;		Serial.print("Azimuth: ");		Serial.print(azimuth);		Serial.print(" AngleXY: ");		Serial.print(angleXY);		Serial.print(" AngleZ: ");		Serial.print(angleZ);		Serial.println();		float tmp = gazimuth-azimuth;		float tmp2 = gangleXY - angleXY;		float tmp3 = gangleZ - angleZ;		Serial.print("az error: ");		Serial.print(tmp);		Serial.print("angXY: ");		Serial.print(tmp2);		Serial.print("angz: ");		Serial.print(tmp3);		Serial.println();		ll = digitalRead(readLightL);		if (actualL != ll && actualL == HIGH) {			++counterL;		}		actualL = ll;		rr = digitalRead(readLightR);		if (actualR != rr && actualR == HIGH) {			++counterR;		}		actualR = rr;		analogWrite(rPin, masterPower);		analogWrite(lPin, slavePower);		uint16_t tP = steps/10;		uint8_t speedL = 0;		if(counterL < tP || (steps-counterL) < tP){			speedL = counterL*255/tP;		}		error = counterL - counterR;		slavePower += error/kp;		slavePower = speedL*slavePower/masterPower;		masterPower = speedL;		if(slavePower<=0 || masterPower<=0){			masterPower=0;			slavePower=0;		}	}	analogWrite(lPin, 0);	analogWrite(rPin, 0);	counterL = 0;	counterR = 0;}void setup() {	Wire.begin();	Serial.begin(9600);	qmc.init();	pinMode(irPin, INPUT);	pinMode(trigPin, OUTPUT);	pinMode(echoPin, INPUT);	pinMode(lPin, OUTPUT);	pinMode(rPin, OUTPUT);	pinMode(lDir1, OUTPUT);	pinMode(lDir2, OUTPUT);	pinMode(rDir1, OUTPUT);	pinMode(rDir2, OUTPUT);	pinMode(readLightL, INPUT);	pinMode(readLightR, INPUT);	circumference = (wheeldiameter * 3.14) / 10;	cm_step = circumference / stepcount;}void loop() {	while (Serial1.available() || Serial.available()) {		if (Serial1.available() > 0) {			char c = Serial1.read();			read_string += c;		}		if (Serial.available() > 0) {			char c = Serial.read();			read_string += c;		}	}	if (read_string.length() > 0) {		char command = read_string.charAt(0);		String tmp = read_string.substring(2, read_string.length());		int amount = tmp.toInt();		switch (command) {			case 'D':				forw();				move2(CMtoSteps(amount), 255);				break;			case 'R':				back();				move2(CMtoSteps(amount), 255);				break;			case 'L':				left();				move2(amount, 255);				break;			case 'P':				right();				move2(amount, 255);				break;			 efault:				break;		}		read_string = "";}